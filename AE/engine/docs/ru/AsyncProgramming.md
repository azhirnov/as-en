Сборник нюансов по асинхронному программированию.

## Атомарные операции (atomics)

**Особенности:**
* Чтение атомика дешевое, если его значение уже хранится в кэше и не было изменено в другом потоке.
* Изменение атомика дешевое, если это не CAS-операция (*сравнение и изменение*), тогда может возникнуть конкуренция между потоками, когда значение долго не получается изменить.
* `relaxed` на ARM платформах дает существенное ускорение.

**Как оптимизировать:**
* Если атомик выровнен по 64 байта (128 на некоторых платформах), то скорость чтения и записи увеличивается.
* Данные, связанные с атомиком желательно размещать в 64 байтном блоке рядом с атомиком.
* Другие атомики, которые меняются в разное время, не должны размещаться в той же кэшлинии (64 байта), это приводит к false sharing - чтение всех атомиков становится дорогим, если изменился хотя бы один из них.

**При конкуренции за один атомик можно:**
* Сделать несколько атомиков и обращаться к ним в зависимости от ID потока.
* Сделать иерархию атомиков, на верхнем уровне очень редко менять, чтобы было дешевое чтение, а на нижнем уровне менять чаще, при условии что не возникнет конкуренция на нижнем уровне. Например битовое дерево не получится так оптимизировать, так как изменение одного бита в худшем случае приводит к изменении всей ветви дерева.

## Корутины (coroutine)

В версии C++20 корутины могут быть опасны:
* Нельзя использовать lambda capture и методы классов, все параметры должны передаваться как параметры корутины, вместо `this` использовать сильную/слабую ссылку. Иначе рано или поздно случится доступ к уже удаленному объекту.


## Привязка потоков к ядрам ЦП (Thread affinity)

**Если привязывать потоки:**
* На ЦП с одинаковыми ядрами и гипертредингом (*2 потока одновременно работают на 1 ядре*) надо привязывать потоки с высоким приоритетом к физическим ядрам. Потоки, с низким приоритетом, а также те, кто могут засыпать при чтении файлов или на примитивах синхронизации, могут привязываться к группе ядер или к виртуальным ядрам.
* На ЦП с производительными и энергоэффективными ядрами, потоки с высоким приоритетом привязываются к производительным ядрам, а потоки с низким приоритетом - к энергоэффективным ядрам.
* При одновременном использовании двух приложений с жесткой привязкой к потокам возникает конкуренция за одни и те же ядра ЦП, что снижает производительность. В таком случае планировщик ОС лучше распределяет потоки, хоть иногда и возникают лишние простои.

**Если НЕ привязывать потоки:**
* Иногда ОС запускает два потока приложения на одном виртуальном ядре, что приводит к сильной конкуренции и потере производительности. Возможно это связано с использованием одного примитива синхронизации, из-за чего ОС решает запустить второй поток там же для лучшей локальности кэша.
* ОС пытается снизить нагрев одного ядра ЦП, поэтому перекидывает потоки на разные ядра, что не очень хорошо для кэша.
* Производительность каждого ядра немного отличается, у ОС есть информация об этом, а у пользователей - нет, поэтому планировщик ОС может эффективнее распределять нагрузку на ЦП.
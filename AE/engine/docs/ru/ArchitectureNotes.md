Заметки по планированию архитектуры.

## ООП

В больших классах частая проблема - множество методов, которые имеют доступ ко всем полям класса.
В чем тут проблема:
* Проблемы с читаемостью - непонятно что где меняется.
* Проблемы с синхронизацией - если поля класса защищены разными примитивами синхронизации, то очень сложно отследить где что используется и была ли синхронизация перед использованием.

Решается это использованием статичных функций, у них остается доступ к приватным типам класса, но нет доступа к полям, для этого их нужно явно передавать, что сразу же улучшает читаемость кода.

Другой вариант это константные методы, они могут читать все поля, но меняют только те, что передаются в виде параметров.
```cpp
class Obj
{
  ReadOnly r;
  Mutable  m;

  static void  StaticFn (const ReadOnly &, Mutable &);
  void  ConstMethod (Mutable &) const;
};
```

## Синхронизации

Если в классе используется mutex или другой примитив синхронизации, то он должен использоваться для всех полей, кроме константных. Иначе это выглядит как ошибка, когда часть методов не используют синхронизацию.

Вместо нескольких примитивов синхронизации внутри одного класса лучше использовать [Synchronized](https://github.com/azhirnov/as-en/blob/dev/AE/engine/src/threading/Primitives/Synchronized.h) тип.


## Исключения

Текущая реализация C++ не позволяет писать безопасный код с использованием исключений.

Проблемы:
* Приходится вручную отслеживать какая функция бросает исключения. Компилятор выдает ошибку, если функция с `noexcept` бросает исключение, которое не перехватывается, но это работает только на явный вызов `throw` внутри функции, а используемые функции могут кидать исключения и компилятор никак это не проверяет. Пока не будет предупреждений на использование не-`noexcept` функций внутри `noexcept` функций исключения будут опасны.
* Концепция исключений предполагает, что после бросания исключений объект возвращается в первоначальное состояние, никаких частичных изменений, либо все, либо ничего, это часто требует выделение дополнительной памяти.
* Бросание исключений в конструкторах, особенно в move-конструкторах, приводит к выделению дополнительной памяти, как описано выше.
* В ObjC бросание исключения внутри `autoreleasepool` приводит к утечке памяти.
* Сложно писать код, который требует соблюдения правил и компилятор в этом никак не помогает, поэтому поддержка исключений усложняет код и увеличивает время разработки.

Преимущества:
* Хорошо подходят для функций, вызываемых из скриптов, тогда в случае бросания исключения скрипт завершается и выдает ошибку из исключения.
* Неплохо подходит для десериализации, где из-за порчи данных может произойти попытка выделить большого объема памяти.

В большинстве случаев достаточно использовать атрибут `[[nodiscard]]`, что позволяет использовать возвращаемые коды ошибок, которые не будут проигнорированы.


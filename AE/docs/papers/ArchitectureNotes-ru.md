Заметки по планированию архитектуры.

## ООП

В больших классах частая проблема - множество методов, которые имеют доступ ко всем полям класса.<br/>
В чем тут проблема:
* Читаемость - непонятно что где меняется.
* Синхронизация - если поля класса защищены разными примитивами синхронизации, то очень сложно отследить где что используется и была ли синхронизация перед использованием.

Возможные решения:
1. Использовать статические функции. У них остается доступ к приватным типам класса, но нет доступа к полям, для этого их нужно явно передавать, что сразу же улучшает читаемость кода.
2. Константные методы. Они могут читать все поля, но меняют только те, что передаются в виде параметров.
3. Приватные классы. В них хранятся только нужные данные и только их логика, но это работает только в редких случаях, так как часто данные нужны везде.

```cpp
class Obj
{
  ReadOnly r;
  Mutable  m;

  static void  StaticFn (const ReadOnly &, Mutable &);
  void  ConstMethod (Mutable &) const;
};
```

## Синхронизации

Если в классе используется mutex или другой примитив синхронизации, то он должен использоваться для всех полей, кроме константных. Иначе это выглядит как ошибка, когда часть методов не используют синхронизацию.

Вместо нескольких примитивов синхронизации внутри одного класса лучше использовать [Synchronized](https://github.com/azhirnov/as-en/blob/dev/AE/engine/src/threading/Primitives/Synchronized.h) тип.


## Асинхронная архитектура

Главное - алгоритмы и архитектура должны изначально разрабатываться под асинхронность.

### Алгоритмы выполняются частями

Например загрузка данных с диска на видеокарту.<br/>
Скорость чтения с диска HDD: ~100Мб/с, SSD: ~500Мб/с, скорость передачи данных по PCI-E: Gen3 x16: 15.75 GB/s, Gen4 x16: 31.5 GB/s.
Если данные занимают несколько Гб, то мы не можем загрузить все с диска в ОЗУ и затем уже передать на видеокарту, это отберет слишком много памяти у других операций. Тогда нужно использовать фиксированный объем ОЗУ, чтобы читать часть с диска, загружать ее на видеокарту и запускать заново. При этом другие операции могут занимать всю фиксированную часть ОЗУ, поэтому наш алгоритм должен сначала пытаться захватить нужный блок памяти.
Чтобы не блокировать шину PCI-E передачей больших объемов данных, требуется передавать их малыми частями каждый кадр. Также захватывается блок видимой для видеокарты ОЗУ, в нее копируется (ОЗУ -> ОЗУ), потом на видеокарте идет копирование из видимой ОЗУ в память видеокарты.<br/>
Поэтому асинхронный алгоритм сильно отличается от синхронного, но правильно написанный алгоритм позволяет распараллелить работу, тогда как синхронный алгоритм упрется в объем ОЗУ, пропускную способность диска или шины PCI-E.

**Требуется следить за выделением памяти.**<br/>
Всегда может возникнуть ситуация, когда один алгоритм запущен множество раз параллельно и требуется выделить слишком много памяти.


## Исключения

Текущая реализация C++ не позволяет писать безопасный код с использованием исключений.

Проблемы:
* Приходится вручную отслеживать какая функция бросает исключения. Компилятор выдает ошибку, если функция с `noexcept` бросает исключение, которое не перехватывается, но это работает только на явный вызов `throw` внутри функции, а используемые функции могут кидать исключения и компилятор никак это не проверяет. Пока не будет предупреждений на использование не-`noexcept` функций внутри `noexcept` функций исключения будут опасны.
* Концепция исключений предполагает, что после бросания исключений объект возвращается в первоначальное состояние, никаких частичных изменений, либо все, либо ничего, это часто требует выделение дополнительной памяти.
* Бросание исключений в конструкторах, особенно в move-конструкторах, приводит к выделению дополнительной памяти, как описано выше.
* В ObjC бросание исключения внутри `autoreleasepool` приводит к утечке памяти.
* Сложно писать код, который требует соблюдения правил и компилятор в этом никак не помогает, поэтому поддержка исключений усложняет код и увеличивает время разработки.

Преимущества:
* Хорошо подходят для функций, вызываемых из скриптов, тогда в случае бросания исключения скрипт завершается и выдает ошибку из исключения.
* Неплохо подходит для десериализации, где из-за порчи данных может произойти попытка выделения большого объема памяти.

В большинстве случаев удобнее использовать коды ошибок и атрибут `[[nodiscard]]`, что не позволит пользователю проигнорировать возвращаемое значение.


## Коды ошибок

Обычно достаточно возвращать `bool` - успешно отработала функция или нет. Ошибки должны обрабатываться внутри функции, а пользователь может передать флаги и функторы (std::function), которые будут вызваны для обработки или исправления ошибки.

Почему плохо возвращать `enum` с кодами ошибок - на каждый вызов функции от пользователя требуется обработать все возможные коды, это сильно увеличивает объем кода, это требует заново читать документацию и тд, тогда как чаще всего пользователю нужно получить ответ успешно ли отработала функция или нет.

Как возвращать данные и код ошибки:
* Как `out` аргументы функции. Обязательные аргументы передаются по ссылке, опциональные - по указателю.<br/>Это требует от пользователя передавать все аргументы, а внутри функции требуется проверять на `null` опциональные параметры. Все это не очень оптимально как для производительности так и для написания кода.
* Вместе с кодом ошибки. Для этого можно использовать `pair`, `tuple`, `optional<>` и тд.<br/> При этом `pair/tuple` требуют чтобы все возвращаемые данные были валидны, так как данные могут быть прочитаны без проверки кода ошибки. А `optional` и аналоги не дают доступ к данным до проверки ошибки.

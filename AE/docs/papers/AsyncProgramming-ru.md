Сборник нюансов по асинхронному программированию.<br/>
Про асинхронную архитектуру написано отдельно [тут](https://github.com/azhirnov/as-en/blob/dev/AE/docs/papers/ArchitectureNotes-ru.md).

## Атомарные операции (atomics)

**Особенности:**
* Чтение атомика дешевое, если его значение уже хранится в кэше и не было изменено в другом потоке.
* Изменение атомика дешевое, если это не CAS-операция (*сравнение и изменение*), тогда может возникнуть конкуренция между потоками, когда значение долго не получается изменить.
* `relaxed` на ARM платформах дает существенное ускорение.

**Как оптимизировать:**
* Если атомик выровнен по 64 байта (128 на некоторых платформах), то скорость чтения и записи увеличивается.
* Данные, связанные с атомиком, желательно размещать в 64 байтном блоке рядом с атомиком.
* Другие атомики, которые меняются в разное время, не должны размещаться в той же кэшлинии (64 байта), это приводит к false sharing - чтение всех атомиков становится дорогим, если изменился хотя бы один из них.

**При конкуренции за один атомик можно:**
* Сделать несколько атомиков и обращаться к ним в зависимости от ID потока.
* Сделать иерархию атомиков, на верхнем уровне очень редко менять, чтобы было дешевое чтение, а на нижнем уровне менять чаще, при условии что не возникнет конкуренция на нижнем уровне. Например битовое дерево не получится так оптимизировать, так как изменение одного бита в худшем случае приводит к изменении всей ветви дерева.


## Корутины (coroutine)

В версии C++20 корутины могут быть опасны:
* Нельзя использовать lambda capture - время жизни переменных в блоке захвата намного меньше времени жизни корутины, только в редком случае это работает корректно.
* Нежелательно использовать методы класса как корутины - время жизни объекта `this` ничем не гарантированно, поэтому надо использовать статичные функции, а `this` передавать как параметр корутины в виде сильной или слабой ссылки.
* Нежелательно использовать указатели и ссылки в параметрах корутины, стоит использовать только умные указатели.


## Привязка потоков к ядрам ЦП (Thread affinity)

**Если привязывать потоки:**
* На ЦП с одинаковыми ядрами и гипертредингом (*2 потока одновременно работают на 1 ядре*) надо привязывать потоки с высоким приоритетом к физическим ядрам. Потоки, с низким приоритетом, а также те, кто могут засыпать при чтении файлов или на примитивах синхронизации, могут привязываться к группе ядер или к виртуальным ядрам.
* На ЦП с производительными и энергоэффективными ядрами, потоки с высоким приоритетом привязываются к производительным ядрам, а потоки с низким приоритетом - к энергоэффективным ядрам.
* При одновременном использовании двух приложений с жесткой привязкой к потокам возникает конкуренция за одни и те же ядра ЦП, что снижает производительность. В таком случае планировщик ОС лучше распределяет потоки, хоть иногда и возникают лишние простои.

**Если НЕ привязывать потоки:**
* Иногда ОС запускает два потока приложения на одном виртуальном ядре, что приводит к сильной конкуренции и потере производительности. Возможно это связано с использованием одного примитива синхронизации, из-за чего ОС решает запустить второй поток там же для лучшей локальности кэша.
* ОС пытается снизить нагрев одного ядра ЦП, поэтому перекидывает потоки на разные ядра, что не очень хорошо для кэша.
* Производительность каждого ядра немного отличается, у ОС есть информация об этом, а у пользователей - нет, поэтому планировщик ОС может эффективнее распределять нагрузку на ЦП.


## Примитивы синхронизации

* Любой примитив синхронизации в чем-то ограничивает параллельное выполнение, поэтому от них нужно избавляться в пользу зависимостей между тасками.
* Для отладки лучше использовать спинлоки вместо мьютексов, тогда в профайлере видно, когда поток не может его захватить, иначе найти заснувший поток намного сложнее.
* Как альтернатива мьютексу - AsyncMutex, он формирует цепочку зависимостей между тасками, которые хотят его захватить, поэтому потоки не простаивают.
* Мьютексами можно защищать данные, параллельное обращение к которым маловероятно. Это имеет смысл, когда зависимости между тасками ставятся вручную и можно пропустить какое-то условие, тогда данные не будут повреждены.

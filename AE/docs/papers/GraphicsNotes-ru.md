

## Деривативы

`dFdxFine` возвращает одинаковое значение для двух пикселей квадрата, то есть на квадрат получается 2 уникальных значения.<br/>
`dFdxCoarse` возвращает одно значение для всего квадрата.

`subgroupQuadBroadcast` возвращает точное значение из каждого потока внутри квадрата.
В фрагментном шейдере `subgroupQuadBroadcast` соответствует реальному квадрату, а в остальных - нет и по координатам из `gl_GlobalInvocationID` "квадрат" оказывается линией.

Эмуляция дериватив через `subgroupQuadBroadcast` для использования в компьют шейдере.
```cpp
#define dFdxFine( x )  (subgroupQuadBroadcast( (x), (gl_SubgroupInvocationID&2)|1 ) - subgroupQuadBroadcast( (x), gl_SubgroupInvocationID&2 ))
#define dFdyFine( x )  (subgroupQuadBroadcast( (x), (gl_SubgroupInvocationID&1)|2 ) - subgroupQuadBroadcast( (x), gl_SubgroupInvocationID&1 ))

#define dFdxCoarse( x )  (subgroupQuadBroadcast( (x), 1 ) - subgroupQuadBroadcast( (x), 0 ))
#define dFdyCoarse( x )  (subgroupQuadBroadcast( (x), 2 ) - subgroupQuadBroadcast( (x), 0 ))
```

Существует расширение `GLSL_NV_compute_shader_derivatives` которое позволяет использовать деривативы в компьют шейдере, а также явно задать расположение пикселей в квадрате.

[Пример](https://github.com/azhirnov/as-en/blob/dev/AE/samples/res_editor/_data/scripts/tests/Derivatives.as).


### SDF и тонкие линии

Для процедурного SDF в 2D деривативы не нужны, если прирост координат идет одинаково по осям и равномерно, например `uv + (1,0)`, `uv + (0,1)`.<br/>
Деривативы нужны:
* для 3D пространства
* для неравномерного 2D
* для SDF текстур.

**Тонкие линии**<br/>

<details><summary>Тонкая линия между пикселями</summary>

![](img/thin_sdf_line.png)
</details>

Деривативы нужны чтобы узнать изменение пространства между соседними пикселями. Они не требуются только в 2D пространстве без искажений, тогда деривативы всегда будут возвращать одинаковую разницу.<br/>
На картинке зеленая линия `uv` - координаты в пространстве, они изменяются равномерно, без перегибов. Красная линия `sdf` - дистанция до линии или любой другой формы, заданной SDF функцией, дистанция измеряется в том же пространстве, что и `uv`.
Часто sdf идет с перегибами, здесь пик оказался между пикселями и потерялся, поэтому минимальное значение sdf смещается на расстояние между пикселями `md`.<br/>
В 3D на расстоянии или под большим углом шаг становится слишком большим и теряются детали в sdf, тогда сглаживание перестает работать и приходится делать затухание.<br/>
[Пример](https://github.com/azhirnov/as-en/blob/dev/AE/samples/res_editor/_data/scripts/samples-2d/AA-Grid.as).

**Шрифты**<br/>
SDF шрифты позволяют их увеличивать и уменьшать не теряя сглаживание. Также как с линиями, при уменьшении шаг градиента увеличивается, чтобы заполнить хотя бы 1 пиксель.<br/>
Константное смещение для градиента (`smoothstep`) используется для изменения стиля шрифта (жирный, контурный).<br/>
[Пример](https://github.com/azhirnov/as-en/blob/dev/AE/samples/res_editor/_data/scripts/samples-2d/SdfFont.as).


### Расчет нормалей и TBN

Tangent и Bitangent вектора должны быть направлены в ту же сторону что и текстурные координаты UV.
Зная как меняется `worldPos` и `uv` можно рассчитать нормаль как векторное произведение и касательные (TB) как 3D вектор для `uv`.

```cpp
float3x3  ComputeTBNinFS (float2 uv, float3 worldPos)
{
    float3  wp_dx = dFdx( worldPos );
    float3  wp_dy = dFdy( worldPos );
    float2  uv_dx = dFdx( uv );
    float2  uv_dy = dFdy( uv );

    float3  t = normalize(  wp_dx * uv_dy.t - wp_dy * uv_dx.t );
    float3  b = normalize( -wp_dx * uv_dy.s + wp_dy * uv_dx.s );
    float3  n = normalize( cross( wp_dy, wp_dx ));

    return float3x3( t, b, n );
}
```

* В большинстве случаев нет разницы между dFdxFine и dFdxCoarse.
* Хорошо работает для плоских поверхностей и небольших изгибов.
* Хорошо работает для карты высот, но только когда высоты в формате float32, для float16 точность теряется и результат хуже.
* Можно использовать как альтернативный способ расчета нормалей для проверки корректности трансформаций у предрасчитаных нормалей.


## Текстуры

### Фильтрация

* Фильтрация R16F текстуры с включенным `mediump float` работает по-разному на NVidia и других ГП. На NV появляются артефакты фильтрации.
* На мобилках требуется `highp sampler2D` для 16-битных форматов иначе теряется точность даже без фильтрации (texelFetch).

* Фильтрация текстур происходит с 8-битной точностью. [ref](https://iquilezles.org/articles/hwinterpolation/)
	- Актуально для 8 и 16 битных форматов.
	- 32 битные форматы (R32F) фильтруются с большей точностью.
	- Проявляется при расчете попиксельных нормалей для карты высот через деривативы.


## Эффекты

### Bloom

Эффект рассеивания света на линзе. Чем больше яркость, тем больше рассеивается. Результат прибавляется к цвету сцены.


## Разное

### Полноэкранный квадрат

Если рисовать через 2 треугольника, то будет задействовано больше потоков, чем при использовании одного треугольника растянутого на [2, 2].

На Adreno выключается TBDR для полноэкранного прохода.

### Multiview vs Viewport array

**Multiview** - позволяет рисовать в массив 2д текстур с разными проекциями на view. Задается через `gl_ViewIndex`.
Используется в VR для рисования в оба глаза за один проход.

**Viewport array** - позволяет рисовать в 2д текстуру с разными проекциями на виюпорт. Задается через `gl_ViewportIndex` в геометричеком шейдере.
Расширение `VK_EXT_shader_viewport_index_layer` позволяет выбирать виюпорт в вершинном шейдере, дублирование геометрии делается через инстансинг.
Используется для ???

**Layered rendering** - позволяет рисовать в массив 2д текстур. Задается через `gl_Layer` в геометричеком шейдере.
Расширение `VK_EXT_shader_viewport_index_layer` позволяет выбирать слой в вершинном шейдере, дублирование геометрии делается через инстансинг.
Используется для рисования кубических карт за один проход.


## Растеризация

* Растеризация, тест глубины и выполнение фрагментного шейдера идет блоками по 2х2 пикселя (quads).
* В тайловой архитектуре (TBR) область в 16х16 пикселя привязана к одному SM, в TBDR архитектуре размер тайла начинается с 16х16, в ARM Mali Valhall архитектуре fragment task заполняет область в 32х32 пикселей, в 5thGen увеличили до 64х64. Поэтому на всех архитектурах рендеринг в текстуру должен быть в область кратную 16, чтобы максимально нагрузить ГП.

## Размер воркгруппы

* На старых мобилках максимальный размер 64 (8х8), поддерживается и 128, но с вдвое меньшим количеством регистров.
* На NV Turing нужно минимум 128 (16х8) потоков чтобы максимально загрузить SM.


## Ветвление в шейдерах

## Микрооптимизация шейдеров

* Компилятор заменяет повторяющиеся деления на одно переворачивание (1/x) и умножения.
* Реализация `Sign` через `Step`, который возвращает -1 или 1, намного быстрее чем `SignOrZero` (`sign` из GLSL), а `copysign` из MSL - быстрее `Step`.
* `FMA` на мобильных работает через `fp32 FMA`, а на NV и Intel использует `fp16 FMA x2` что в 2 раза быстрее fp32 для half2, half4.
* `[[unroll]]` сильно замедляет компиляцию пайплайна, в редких случаях дает 2х ускорение, но часто слабо влияет.
* На NV mediump может работать медленнее чем highp, на мобильных аналогично fp16.
* Для uint `FindMSB` в 2 раза быстрее `FindLSB`, для int `FindLSB` может быть быстрее.
* На NV/AMD/Intel FP32ADD выполняется в 2 раза быстрее чем FP32FMA, FP32MUL.
* На мобилках FP32ADD, FP32MUL, FP32FMA выполняется за один цикл.
* В спецификациях считают FMA за 2 инструкции и указывают в 2 раза большую производительность.

**SFU** pipe (special function unit) - на нем выполняются более редкие операции типа переворачивания (1/x), sqrt, sin, cos, exp, log, fract, ceil, round, sign и тд.
Чаще всего на 4 потока варпа приходится 1-2 SFU, поэтому все перечисленные операции относительно медленные, но некоторые выполняются за одну инструкцию, а другие эмулируются и занимают еще больше времени.
Обычно заточен только под fp32 тип и не имеет оптимизаций под mediump и fp16.<br/>
В зависимости от производителя стоимость операций может сильно отличаться, иногда Round в 10 раз дольше Fract, а Length в 2 раза быстрее InvSqrt и Sqrt, на одних деление в 2 раза быстрее Sqrt, на других одинаково.
Normalize часто сделан через 1/Length, а Distance через Length(a - b), поэтому работают чуть медленнее чем Length. Где-то Pow сделан через умножение, поэтому время выполнения растет от степени, а где-то Pow работает за константное время.<br/>
В среднем 4 цикла: div, InvSqrt, Sqrt, Fract, SignOrZero, Length, SmoothStep.<br/>
В среднем 8 циклов: mod, Pow, Exp, Log, Round, Sin, Cos, SinH, CosH.<br/>
От 12 циклов: ASin, ACos, Tan, ATan.<br/>

**Операции сравнения** чаще всего выполняются за 1 цикл.<br/>
Это equal, lessThan, Min, Max, Step.

**Приведение к диапазону** (clamp) выполняются за 1-4 цикла.<br/>
Отдельный случай: `clamp(x,0,1)` может быть одной инструкцией типа `add_sat`.<br/>
У некоторых производителей `clamp(x,-1,1)` работает как и `clamp(x,0,1)` за один цикл.<br/>
Clamp без констант работает за 3-4 цикла.


**Конвертация типов**<br/>
Битовый каст типа uintBitsToFloat работает быстрее всего.<br/>
В среднем 4 цикла занимает конвертация между int и float.<br/>

**Integer типы**<br/>
Битовые операции и сложение работает за 1 цикл. На мобильных архитектурах может быть медленее и доходить до 2-4 циклов. На некоторых архитектурах может работать параллельно с float, на других - часть float блоков отключается и теряется производительность.<br/>
Около 4 циклов: mul, FindMSB(uint), BitCount.<br/>
От 8 циклов: FindLSB, FindMSB(int), uaddCarry, usubBorrow.<br/>
От 16 циклов: div, mod, umulExtended.<br/>

Подробные результаты микробенчмарков: [GPU_Benchmarks](GPU_Benchmarks.md)


## Профилирование на мобилках

Чаще всего доступны счетчики производительности, часть из них в количестве (циклы, байты, транзакции и тд), часть в процентах. Для количественных значений нужно запускать микробенчмарки чтобы найти максимальное значение за кадр или за секунду, например GB/s для памяти. Значения из спецификаций не всегда совпадают с измеряемыми, и сами спецификации на тсмартфоны содержат ошибки.

Главный показатель это частота ГП. Если на ГП нет нагрузки, то для экономии энергии частота понижается. Многие счетчики в процентах могут при этом показывать до 100% нагрузки, но пока частота низкая это не имеет особого значения.

Второй показатель это нагрузка на внешнюю память (RAM, external memory). Если нагрузка приближается к максимальной, значит кэши не используются.
